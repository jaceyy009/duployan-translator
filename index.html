<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duployan Translator</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 900px; margin: 20px auto; padding: 20px; background: #f9f9f9; }
        h1 { text-align: center; color: #222; }
        .container { background: white; padding: 25px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        textarea, select, button { width: 100%; padding: 12px; margin: 10px 0; border: 1px solid #ccc; border-radius: 6px; font-size: 16px; box-sizing: border-box; }
        button { background: #4CAF50; color: white; cursor: pointer; }
        button:hover { background: #45a049; }
        #output { background: #f0f8ff; padding: 15px; border-radius: 6px; white-space: pre-wrap; min-height: 100px; margin-top: 15px; font-family: monospace; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Duployan Translator</h1>
        <p>Enter English sentence (e.g. "Keep all the noise down"). Round-trip should now be reasonable for simple sentences.</p>

        <textarea id="input" rows="4" placeholder="Type sentence here..."></textarea>

        <select id="dir">
            <option value="en2dup">English â†’ Duployan</option>
            <option value="dup2en">Duployan â†’ English</option>
        </select>

        <button onclick="translateText()">Translate</button>
        <button onclick="clearAll()">Clear</button>

        <div id="output"></div>
    </div>

    <script>
        // Vocabulary - core + your new requested words
        const vocab = {
            // Pronouns
            'i':         {dup: 'ð›±ˆ', pron: 'eeh'},
            'you':       {dup: 'ð›°‘ð›±‘', pron: 'th-u'},
            'he':        {dup: 'ð›°€ð›±†', pron: 'hee'},
            'she':       {dup: 'ð›°†ð›±†', pron: 'lee'},
            'we':        {dup: 'ð›°‰ð›±†', pron: 'vee'},
            'they':      {dup: 'ð›°‘ð›±’', pron: 'th-eu'},
            'it':        {dup: 'ð›±‹ð›°‘', pron: 'eeh-th'},

            // Core verbs
            'be':        {dup: 'ð›°‘ð›±', pron: 'tha'},
            'have':      {dup: 'ð›°™ð›±†', pron: 'mee'},
            'go':        {dup: 'ð›°…ð›£¼', pron: 'ko'},
            'come':      {dup: 'ð›°…ð›±ð›°™', pron: 'kam'},
            'see':       {dup: 'ð›°œð›±†', pron: 'see'},
            'say':       {dup: 'ð›°œð›±ð›°†', pron: 'sal'},
            'learn':     {dup: 'ð›°†ð›£¼ð›°š', pron: 'lon'},
            'know':      {dup: 'ð›°šð›£¼', pron: 'no'},
            'make':      {dup: 'ð›°™ð›±ð›°…', pron: 'mak'},
            'use':       {dup: 'ð›°‘ð›±•ð›°œ', pron: 'th-oos'},

            // New words you requested (logical Duployan forms)
            'keep':      {dup: 'ð›°šð›±•ð›°‹', pron: 'noor'},   // "keep/hold"
            'down':      {dup: 'ð›°‡ð›±‘ð›°…', pron: 'buk'},
            'here':      {dup: 'ð›±ˆð›°‹', pron: 'eehr'},
            'your':      {dup: 'ð›±†ð›°œð›£¼', pron: 'eeso'},
            'leave':     {dup: 'ð›±‚ð›°„', pron: 'owuhf'},

            // Time & particles
            'now':       {dup: 'ð›°‘', pron: 'th'},
            'before':    {dup: 'ð›°ƒð›±‚', pron: 'tow-uh'},
            'after':     {dup: 'ð›°‹ð›±', pron: 'ra'},
            'past':      {dup: 'ð›°ƒð›±‚', pron: 'tow-uh'},
            'future':    {dup: 'ð›°‹ð›±', pron: 'ra'},
            'progressive': {dup: 'ð›°œð›±†', pron: 'see'}
        };

        const dupToEng = {};
        for (let eng in vocab) {
            dupToEng[vocab[eng].dup] = eng;
        }

        function translateText() {
            const text = document.getElementById('input').value.trim();
            const dir = document.getElementById('dir').value;
            let output = '';

            if (!text) {
                output = 'Please enter a sentence.';
            } else if (dir === 'en2dup') {
                const [dup, pron] = englishToDuployan(text);
                output = `Duployan: ${dup}\nPronunciation: ${pron}`;
            } else {
                const eng = duployanToEnglish(text);
                output = `English: ${eng}`;
            }

            document.getElementById('output').textContent = output;
        }

        function clearAll() {
            document.getElementById('input').value = '';
            document.getElementById('output').textContent = '';
        }

        function englishToDuployan(sentence) {
            let words = sentence.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
            let tense = 'current';
            if (words.includes('will')) tense = 'future';
            if (words.some(w => ['was', 'did', 'had', 'went', 'made'].includes(w))) tense = 'past';

            let subject = null;
            let verb = null;
            let objects = [];

            for (let w of words) {
                if (vocab[w]) {
                    if (['i','you','he','she','we','they','it'].includes(w)) {
                        subject = w;
                    } else if (!verb && ['be','have','go','come','see','say','learn','know','make','use','keep','leave'].includes(w)) {
                        verb = w;
                    } else {
                        objects.push(w);
                    }
                }
            }

            if (!subject || !verb) {
                return ['Could not parse - needs subject + verb', ''];
            }

            let dupParts = [vocab[tense].dup, vocab[verb].dup, vocab[subject].dup];
            if (objects.length) {
                dupParts.push(objects.map(w => vocab[w]?.dup || w).join(' '));
            }

            let pronParts = [vocab[tense].pron, vocab[verb].pron, vocab[subject].pron];
            if (objects.length) {
                pronParts.push(objects.map(w => vocab[w]?.pron || w).join(' '));
            }

            return [dupParts.filter(Boolean).join(' '), pronParts.filter(Boolean).join(' - ')];
        }

        function duployanToEnglish(dupStr) {
            let tokens = dupStr.split(/\s+/).filter(Boolean);
            if (tokens.length < 2) return 'Invalid Duployan (too short)';

            let tenseDup = tokens[0];
            let verbDup = tokens[1];
            let subjDup = tokens[2];
            let objs = tokens.slice(3);

            let tense = dupToEng[tenseDup] || 'current';
            let verb = dupToEng[verbDup] || '[unknown]';
            let subject = dupToEng[subjDup] || '[unknown]';
            let objStr = objs.map(t => dupToEng[t] || t).join(' ');

            let result = `${subject} ${verb}`;
            if (objStr) result += ` ${objStr}`;

            if (tense === 'past') result = `${subject} did ${verb} ${objStr}`;
            if (tense === 'future') result = `${subject} will ${verb} ${objStr}`;

            return result.trim() || 'Could not reconstruct English';
        }
    </script>
</body>
</html>
